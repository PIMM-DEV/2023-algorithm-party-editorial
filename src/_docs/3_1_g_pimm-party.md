---
title: G. PIMM 파티
tags: ["dp", "dp_connection_profile", "dp_bitfield"]
layout: problem
level: insane
author: 0do
checker: ["jk410", "kiwiyou", "lycoris1600", "tony9402"]
first_solve: xiaowuc1 (57분)
ac_ratio: 25.926%
---

문제에서 주어진 조건을 먼저 보겠습니다. 인싸와 아싸가 서로 접해있다면, 인싸는 행복해지는 조건을 충족하게 되지만 아싸는 행복하지 못하게 되므로 모두가 행복한 파티의 조건을 충족할 수 없습니다. 즉, 모든 인싸와 모든 아싸끼리 서로 떨어진 상태에서, 모든 인싸가 최소 한 명 이상의 인싸를 붙어있게만 한다면 모두가 행복한 파티의 조건을 충족할 수 있습니다. 이때, 문제에서는 인싸만을 배치할 것을 요구합니다. 따라서, 이 문제는 아싸와 인접한 칸이 아닌 곳에 인싸를 배치하는 경우의 수를 찾는 문제로 변형할 수 있습니다.

이렇게 문제를 변형하고 나면, 다이나믹 프로그래밍 기법을 사용하여 이 문제를 해결할 수 있음을 알게 됩니다. 이 문제는 격자에서 비트마스킹 DP를 사용하는 문제들과 동일하게 접근할 수 있습니다. 이러한 문제들은, 최근 M(또는 N)개 칸의 상태만 저장해도 그 이전 칸의 상태는 경우의 수를 계산하는 데 영향을 주지 않습니다. 문제에서 X명의 인싸를 배치해야 한다는 조건이 추가적으로 주어지는데, 이 부분은 DP 배열에 한 개의 차원을 추가하는 것으로 해결할 수 있습니다.

일반적인 비트마스킹 DP 문제와는 다르게, 이 문제에서는 각 칸의 상태를 3개로 분류해서 저장하여야 합니다. 즉, 3진법 구현이 이 문제에서 요구됩니다. 인싸가 배치되지 않은 칸의 상태는 0, 아직 행복하지 않은 인싸가 배치된 칸의 상태는 1, 행복한 인싸가 배치된 칸의 상태는 2로 저장합니다. 새로운 칸에 2를 배치할 경우, 1이 저장된 인접 칸의 값을 2로 바꿔주어야 합니다. 모든 과정이 끝난 후 정답을 출력할 때 1이 저장된 칸을 답에 고려해서는 안 됩니다. 

정답 코드의 시간 복잡도는 $O(3^MNMX)$입니다. 문제에서 주어진 N과 M의 크기가 작기 때문에 비트마스킹 기법을 이용한 $O(4^MNMX)$ 구현 등 다양한 구현 방법이 정답 처리를 받을 수 있으며, 이 부분은 출제 과정에서 의도된 것입니다.
